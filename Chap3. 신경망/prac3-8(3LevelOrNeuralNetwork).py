# 행렬곱을 이용하여 3층 신경망의 순방향 처리 구현
# 입력값 2개, 출력값 2개
# 입력층에 2개의 뉴런, 1번째 은닉층에 3개의 뉴런, 2번째 은닉층에 2개의 뉴런, 출력층에 2개의 뉴런이 존재한다 가정

import numpy as np

# ============== 입력층(2개) -> 1번째 은닉층(3개) ==============

# X에 2개 입력값이 저장된 배열 저장
X = np.array([1.0,0.5])
# 1번째 은닉층의 뉴런이 3개이므로 W1에 2×3 크기의 행렬로 6개의 가중치 저장 (각 입력값에서 각 은닉층으로 향하는 가중치 필요)
W1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]])
# 1번째 은닉층의 뉴런이 3개이므로 B1에 3개 편향값이 저장된 배열 저장 (각 은닉층으로 향하는 값에 더해질 편향 필요)
B1 = np.array([0.1,0.2,0.3])

# 활성화 함수로 사용할 시그모이드 함수 정의
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# 입력값과 가중치, 편향을 이용하여 각 출력값을 계산한 후 A1에 넘파이 배열로 저장
A1 = np.dot(X,W1)+B1
# 계산 결과를 시그모이드 함수에 입력하여 활성화 값을 Z1에 넘파이 배열로 저장 (1번째 은닉층 노드들의 최종 값)
Z1 = sigmoid(A1)

# W1의 행렬 형상 : 2×3
print(W1.shape)
# X의 행렬 형상 : 2
print(X.shape)
# B의 행렬 형상 : 3
print(B1.shape)

# A1(이전 노드(입력값)에 가중치, 편향을 계산한 값) 출력
print(A1)
# Z1(1번째 은닉층 노드에 저장된 값) 출력
print(Z1)

# ============== 1번째 은닉층(3개) -> 2번째 은닉층(2개) ==============

# 1번째 은닉층의 뉴런이 3개, 2번째 은닉층의 뉴런이 2개이므로 W2에 3×2 크기의 행렬로 6개의 가중치 저장
W2 = np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])
# 2번째 은닉층의 뉴런이 2개이므로 B2에 2개 편향값이 저장된 배열 저장
B2 = np.array([0.1,0.2])

# Z1의 행렬 형상 : 3
print(Z1.shape)
# W2의 행렬 형상 : 3×2
print(W2.shape)
# B2의 행렬 형상 : 2
print(B2.shape)

# Z1(1번째 은닉층 배열)과 가중치, 편향을 이용하여 각 출력값을 계산한 후 A2에 넘파이 배열로 저장
A2 = np.dot(Z1,W2)+B2
# A2에 저장된 계산 결과를 활성화 함수(시그모이드 함수)에 입력하여 활성화 값을 Z2에 넘파이 배열로 저장 (2번째 은닉층 노드들의 최종 값)
Z2 = sigmoid(A2)

# A2(이전 노드(1번째 은닉층)에 가중치, 편향을 계산한 값) 출력
print(A2)
# Z2(2번째 은닉층에 저장된 값) 출력
print(Z2)

# ============== 2번째 은닉층(2개) -> 출력층(2개) ==============

# 항등함수 정의 (코드 구조 일관성을 위해 임의로 정의)
def identify_function(x):
    return x

# 2번째 은닉층이의 뉴런이 2개, 출력층의 뉴런이 2개이므로 W3에 2×2 크기의 행렬로 4개의 가중치 저장
W3 = np.array([[0.1,0.3],[0.2,0.4]])
# 출력층의 뉴런이 2개이므로 B2에 2개 편향값이 저장된 배열 저장
B3 = np.array([0.1,0.2])

# Z2(2번째 은닉층 배열)과 가중치, 편향을 이용하여 각 출력값을 계산한 후 A3에 넘파이 배열로 저장
A3 = np.dot(Z2,W3)+B3
# A3에 저장된 계산 결과를 항등 함수에 입력하여 그 결과값을 Y에 저장 (최종 출력 값)
Y = identify_function(A3)

